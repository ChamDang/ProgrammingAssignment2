source(ProgrammingAssignment2/cachematrix.R)
clear
my_matrix <- makecachematrix(matrix(1:4, 2, 2))
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
my_matrix <- makecachematrix(matrix(1:4, 2, 2))
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
source(C:/Users/Win7-64 SP1/ProgrammingAssignment2/cachematrix.R)
source(C:Users/Win7-64 SP1/ProgrammingAssignment2/cachematrix.R)
source(~/ProgrammingAssignment2/cachematrix.R)
source(C/Users/Win7-64 SP1/ProgrammingAssignment2/cachematrix.R)
source(C Users Win7-64 SP1/ProgrammingAssignment2/cachematrix.R)
source("ProgrammingAssignment2/cachematrix.R")
source("ProgrammingAssignment2/cachematrix")
source("ProgrammingAssignment2/cachematrix.r")
View(makeCacheMatrix)
open(con, ...)
## S3 method for class 'connection':
open(con, open = "r", blocking = TRUE, ...)
open(cachematrix)
## S3 method for class 'connection':
open(cachematrix, open = "r", blocking = TRUE)
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
f <- function(a, b) {
a^2
}
f(2)
f(2)
my_matrix <- makeCacheMatrix(matrix(1:4,2, 2))
my_matrix$get()
my_matrix$getInverse()
cachesolve(my_matrix)
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
## This function computes the inverse of the special "matrix" created by
## makeCacheMatrix above. If the inverse has already been calculated (and the
## matrix has not changed), then it should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
j
View(f)
View(makeCacheMatrix)
View(f)
View(makeCacheMatrix)
cacheS
Cachesolve
View(makeCacheMatrix)
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
my_matrix$getInverse()
cacheSolve(my_matrix)
makeCacheMatrix <- function(mtx = matrix()) {
inverse <- NULL
set <- function(x) {
mtx <<- x;
inverse <<- NULL;
}
get <- function() return(mtx);
setinv <- function(inv) inverse <<- inv;
getinv <- function() return(inverse);
return(list(set = set, get = get, setinv = setinv, getinv = getinv))
}
cacheSolve <- function(mtx, ...) {
inverse <- mtx$getinv()
if(!is.null(inverse)) {
message("Getting cached data...")
return(inverse)
}
data <- mtx$get()
invserse <- solve(data, ...)
mtx$setinv(inverse)
return(inverse)
}
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
my_matrix$getInv()
my_matrix$getInverse()
cacheSolve(my_matrix)
cacheSolve(my_matrix)
my_matrix$getInv()
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$getInverse()
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$getInv()
## The following is a pair of functions that cache and compute the
## inverse of a matrix.
## This function creates a special "matrix" object
## that can cache its inverse.
makeCacheMatrix <- function(mtx = matrix()) {
inverse <- NULL
set <- function(x) {
mtx <<- x;
inverse <<- NULL;
}
get <- function() return(mtx);
setinv <- function(inv) inverse <<- inv;
getinv <- function() return(inverse);
return(list(set = set, get = get, setinv = setinv, getinv = getinv))
}
## This function computes the inverse of the special
## "matrix" returned by `makeCacheMatrix` above. If the inverse has
## already been calculated (and the matrix has not changed), then
## `cacheSolve` should retrieve the inverse from the cache.
cacheSolve <- function(mtx, ...) {
inverse <- mtx$getinv()
if(!is.null(inverse)) {
message("Getting cached data...")
return(inverse)
}
data <- mtx$get()
invserse <- solve(data, ...)
mtx$setinv(inverse)
return(inverse)
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
cacheSolve(m)
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv <<- inverse
getinverse <- function() inv
list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data.")
return(inv)
}
data <- x$get()
inv <- solve(data)
x$setinverse(inv)
inv
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
makeCacheMatrix <- function(mtx = matrix()) {
inverse <- NULL
set <- function(x) {
mtx <<- x
inverse <<- NULL
}
get <- function() mtx
setinv <- function(inv) inverse <<- inv
getinv <- function() inverse
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
cacheSolve <- function(mtx, ...) {
inverse <- mtx$getinv()
if(!is.null(inverse)) {
message("Getting cached data.")
return(inverse)
}
data <- mtx$get()
inverse <- solve(data)
mtx$setinv(inverse)
inverse
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(mtx)
m$get()
makeCacheMatrix <- function(mtx = matrix()) {
inverse <- NULL
set <- function(x) {
mtx <<- x
inverse <<- NULL
}
get <- function() mtx
setinv <- function(inv) inverse <<- inv
getinv <- function() inverse
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
cacheSolve <- function(mtx, ...) {
inverse <- mtx$getinv()
if(!is.null(inverse)) {
message("Getting cached data.")
return(inverse)
}
data <- mtx$get()
inverse <- solve(data)
mtx$setinv(inverse)
inverse
}
mtx = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(mtx)
m$get()
cacheSolve(mtx)
cacheSolve(m)
cacheSolve(m)
